---
layout: post
title: ESP
feature-img:
categories: IoT
tags: [iot, lora, linux, esp, heltec, heltec-v3, esp32, esp8266]
---

ESP are cool. Let s bend them to our needs.

# ESP

## Meshtastic

### Heltec v3

#### Linux setup

First you ll need Python and Pip installed. You ll figure it out.  
Then install esptool

```bash
yay -S esptool
```

Clone the repo :
```bash
git clone git@github.com:meshtastic/firmware.git
cd firmware
git switch tags/v2.5.19.f9876cf # which is the latest tag at the moment, adapt
```

#### Da build
in order to build and especially upload, we ll use Platformio. I tried to install it system wide, it did compile the firmware, but during the upload process, it tried to pip-install some modules and failed. Therefore I would recommend the following :

```bash
# Setting up the env
uv venv .venv
source .venv/bin/activate
uv pip install platformio

# Now We can play with pio
pio system info
pio pkg list

# List all available envs
pio project config | grep env: [ | grep heltec ]

# Teh build
pio run -e heltec-v3

# Teh upload
pio run -e heltec-v3 -t upload --upload-port /dev/ttyUSB0
```

#### Bonus
Change the name on the splash screen.  
Edit the following file : src/graphics/Screen.cpp.
Around line 168, look for 'const char *title = "meshtastic.org";' and replace it by whatever name you want.  
Side note :  
The line before is : "#ifdef USERPREFS_SPLASH_TITLE", so I am pretty sure there is better way to make a custom splashscreen

### T114

The process is pretty similar. I had an issue while trying to upload the firmware using the USB port, as it seemed that none was found (plug on the same port as before, using the same cable). By removing the --upload-port, it worked, using /dev/ttyACM0. I am not sure why one is discovered on the USB port and the other on the ACM port.
```bash
pio run -e heltec-mesh-node-t114 -t upload
```
Edit : This difference would come from the different chip used on the board. Heltec v3 is using a USB-UART converter and appears on USB, whereas the t114 uses native USB (CDC-ACM) and appears on ACM.

## ESP

### ESP-32

It follows pretty much the same principles, except... We are going to build the firmware.  
We can use different framework to do so. We ll first explore the Arduino style, then the ESP-IDF style and finally we ll use Rust.

#### Arduino
##### Step 1
```bash
mkdir arduino
cd arduino

# setup the project
uv venv .venv
source .venv/bin/activate
uv pip install platformio

```
##### Step 2
```bash
# first try !
pio init --board esp32dev # TODO : add board list
```

This will create the directory structure and download the necessary lib. For the sake of the example lets copy this code inside the src folder :
```cpp
#include <Arduino.h>

#define LED_PIN 2

void setup() {
  pinMode(LED_PIN, OUTPUT);
}

void loop() {
  digitalWrite(LED_PIN, HIGH);
  delay(500);  // 500ms
  digitalWrite(LED_PIN, LOW);
  delay(500);
}

```

And finally build + upload

```bash
pio run -t upload
```

#### ESP-IDF
##### Step 1
Same same
##### Step 2
```bash
# first try !
pio init --board esp32dev --project-option="framework=espidf"
```
And now copy this code inside of src/main.c
```c
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/gpio.h"

#define LED_PIN GPIO_NUM_2

void app_main(void)
{
    gpio_reset_pin(LED_PIN);
    gpio_set_direction(LED_PIN, GPIO_MODE_OUTPUT);

    while (1) {
        gpio_set_level(LED_PIN, 1);
        vTaskDelay(500 / portTICK_PERIOD_MS);

        gpio_set_level(LED_PIN, 0);
        vTaskDelay(500 / portTICK_PERIOD_MS);
    }
}

```
Compile and upload
```bash
pio run
prio run -t upload
```











